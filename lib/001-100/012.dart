/*
*   The sequence of triangle numbers is generated by adding the natural numbers.
*   So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
*   The first ten terms would be:
*   1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
* 
*   Let us list the factors of the first seven triangle numbers:
*
*    1: 1
*    3: 1,3
*    6: 1,2,3,6
*   10: 1,2,5,10
*   15: 1,3,5,15
*   21: 1,3,7,21
*   28: 1,2,4,7,14,28
*
*   We can see that 28 is the first triangle number to have over five divisors.
*   
*   What is the value of the first triangle number to have over five hundred divisors?
*/

import 'dart:math';

import '../helpers/measure_runtime.dart';

void main() {
  executeAndMeasure(solution);
}

/// * The nth triangle number is defined by n * (n + 1) / 2
/// * I'll try to treat it as a binary search (since the triangle numbers are
///   increasingly sorted by definition). I'll pick a random pivot, and as
///   long as I'm getting less than 500 divisors, I'll keep going up. Once I
///   reach one that has 500 divisors, I'll start going down until I get to
///   a point where the number of divisors is lower by 4
///
/// Update after running - this takes way too long and I have no idea if it
/// works, I need another way
void attemptThatTakesTooLong() {
  const targetDivisors = 500;

  var divisors = 0;
  var n = 0;
  while (divisors < targetDivisors) {
    n += targetDivisors * 100;
    print('N $n');
    divisors = 0;
    final number = n * (n + 1) ~/ 2;
    for (var i = 1; i <= number; i++) {
      if (number % i == 0) divisors++;
    }
  }

  var solution = n;

  // by now we reached an nth triangle number with 500 or more divisors
  var lowerDivisor = targetDivisors;
  while (lowerDivisor > targetDivisors - 4) {
    n -= 1;
    divisors = 0;
    final number = n * (n + 1) ~/ 2;
    for (var i = 1; i <= number; i++) {
      if (number % i == 0) divisors++;
    }
    if (divisors >= targetDivisors) {
      solution = n;
    }
    lowerDivisor = min(lowerDivisor, divisors);
  }

  print('Solution is ${solution * (solution + 1) ~/ 2}');
}

/// Brute force?
/// First try: pure brute force took ages. I added a tiny optimization and that
/// made an insanely huge improvement (by looping only to the sqrt and
/// multiplying the divisors by 2)
void solution() {
  const targetDivisors = 500;

  var divisors = 0;
  var n = 0;
  while (divisors < targetDivisors) {
    n++;
    divisors = 0;
    final number = n * (n + 1) ~/ 2;
    for (var i = 1; i <= sqrt(number); i++) {
      if (number % i == 0) divisors++;
    }
    divisors *= 2;
  }

  print('Solution is ${n * (n + 1) ~/ 2}');
}

/*
*   Overview: https://projecteuler.net/overview=012
*
*   Brute force with the optimization was acceptable, the rest of the 
*   optimizations relies on maths (as I would expect)
*/
